Combined the use of the protobuff with the TCP protocol. The ForListener class, in theory, should work on the server, therefore it is designed as a separate project. He is constantly listening.

In the ForClient class, the connection is one-time. only when there is a need. When the server sends a response to the client, the stream is closed and the server waits for a new client.
They transmit a message that is generated by the protobuff and encoded by it. A plus to the answer itself is the address of the person who sent (I thought to use a desktop or domain name, but did not reach) and the time of sending.

Try/catch blocks were needed when I experimented, but for the sake of universality of the code, I decided not to remove them.

///

Совместила использование протобафа с протоколом ТСP. Клас ForListener по идее должен работать на сервере, потому оформлен отдельным проектом. Он постоянно в состоянии прослушивания.

В классе ForClient подключение одноразовое. только когда есть необходимость. Когда сервер отправит ответ клиенту, поток закрывается и сервер ждет нового клиента. 
Передают они сообщение, которое сгенерировано протобафом и им же кодируется. Плюсом к самому ответу идет адрес того, кто отправил (думала использовать десктопное или доменное имя, но не дотянулась) и время отправки.

Блоки try/catch были нужны, когда я экспериментировала, но для универсальности кода решила их не убирать.
